/* chapter5 표현식과 연산자 */

// 5.1 연산자

// 5.2 산술 연산자
    // + - / * % ......
    // 전위 , 후위 연산자

// 5.3 연산자 우선순위
    // 좌에서 우로 , 괄호 , 곱 , 나눗셈 ...

// 5.4 비교 연산자
    // === 일치함  == 동등함 , 대소관계

// 5.5 숫자 비교
    // NaN === NaN  -> false
    // NaN == NaN -> false

    // 자바스크립트의 숫자는 모두 더블(근사치)이므로 숫자 비교때 오류 발생할 수 있음
let n = 0;
while (true) {
    n += 0.1;
    if(n ===0.3) break;
}
console.log(`Stopped at ${n}`);
// n이 3회째 n = 0.30000000000004  가 됩니다. 

// 5.6 문자열 병합
    // js는 피연산자의 타입을 보고 덧셈과 문자열 병합중 판단을 하게됩니다.
    // 모두 왼쪽에서 오른쪽으로 평가합니다.

// 5.7 논리 연산자
    // true , false

    // 5.7.1 참 같은값 거짓 같은 값
    // while(1)  -> 1이 참 인값을 대체한다.
    // 빈 배열의 arr.length -> 0    0이 거짓인 값을 대체한다.

// 5.8 AND , OR , NOT 

    // AND  &&  두 값이 모두 참일때만 참 반환  
    // OR   ||  두 값 중 하나라도 참이면 참 반환
    // NOT  !   피연산자를 반대로 바꿈

    // 5.8.1 단축 평가
        // AND 연산에서 ( A && B)  A가 거짓인경우 B의 여부와 관계없이 false가 됩니다.
        
        const skipIt = true;
        let x = 0;
        const result = skipIt || x++;

        // skipIt 가 true 이므로 x의 값이 변하지않고 0인 상태입니다.
    

    // 5.8.3 조건 연산자
        // 3항 연산자 ? 표현 피연산자를 3개를 받습니다
        // A ? B : C  A가 참이면 B 반환 거짓이면 C를 반환합니다.

    // 5.8.4 쉼표 연산자

// 5.9 연산자 그룹 

    // !-------------------------check!----------------------------------!
    // 5.9.1 비트 연산자 
        // 2의 보수 형식으로 저장된 32비트 부호 붙은 정수로 간주합니다.
    // 비트 AND &   
    // 비트 OR  |
    // 비트 XOR ^ 
    // 비트 NOT ~ 
    // << 왼쪽 시프트 2를 곱하는 효과가 있음
    // >> 오른쪽 시프트 2로 나눈후 소숫점 아래를 버리는 효과가 있음
    // >>> 오른쪽 시프트 후 0으로 채우는 시프트 

    // 5.9.2 typeof 연산자 
        // 피연산자의 타입을 반환하는 연산자 입니다 .

// 5.10 해체 할당
    // 객체나 배열을 변수로 '해체' 할 수 있습니다.
    
    // 객체 선언
    const obj = { b: 2, c: 3, d: 4};

    // 객체 해체 할당
    const {a, b, c} = obj;

    // 객체를 해체할때에는 변수 이름과 객체의 프로퍼티 이름이 일치해야 합니다. 

    // 배열 선언
    const arr = [ 1, 2, 3];

    // 배열 해체 할당
    let [x, y] = arr;


// if else -> 3항 연산으로 변경
if (isPrime(n)) {
    label = 'prime';
} else {
    label = 'non-prime';
}

label = isPrime(n) ? 'prime' : 'non-prime';