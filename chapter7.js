// scope 스코프 

// 스코프는 변수 , 상수 , 매개변수가 언제 어디서 정의합니다.

// 현재 실행 중인 부분 , 현재 보이고 접근 할 수 있는 식별자들을 말합니다.

// 무언가가 더는 존재하지 않는다고 해도 JS는 메모리를 바로 회수하지 않습니다. 
//  필요없음을 표기하게 되면 주기적으로 일어나는 garbage collection 프로세스에서 메모리를 회수합니다.

// 정적, 동적 스코프
// JS 는 기본적으로 정적인 스코프를 가지고 있습니다. 
// 함수를 호출할 때 동적으로 스코프가 정해진다.

// 전역 스코프 ( 전역 변수 )는 주의해서 사용합시다 

// 7.5 변수 숨기기
    // 다른 스코프에 있으면서 이름이 같은 변수나 상수는 혼란을 일으키기 쉽습니다.

{
    // BLOCK 1
    const x = 'blue';
    console.log(x);
}
console.log(typeof x);

{
    // BLOCK 2
    const x = 3;
    console.log(x);
}
console.log(typeof x);

// 스코프는 계층적이기 때문에 이전 스코프를 떠나지 않아도 새 스코프에 진입 할 수가 있습니다. 
// 변수를 숨기게 ㅚ면 그 변수는 해당이름으로는 절대 접근 할 수 없습니다.

// 7.6 함수 , 클로저 , 정적 스코프

// 클로저 -> 함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의하는 경우
// 스코프를 함수 주변으로 closing 하는 것 이라고 생각하면됨

let globalFunc;
{
    let blockVar = "a";
    globalFunc = function() {
        console.log(blockVar);
    }
    let a = "일반적";
}
globalFunc(); // 호출가능 
// console.log(a); // 정의 되지 않음 

// 함수를 정의해 클로저를 만들면 접근할수 없었던 것에 대해 접근할 방법이 생깁니다.

// 즉시 호출하는 함수 표현식
(function() {
    //IIFE 바디
})(); // 호출 
// 내부에 있는 것들이 자신만의 스코프를 가지지만 함수기 때문에 밖으로 내보낼 수가 있습니다.


// 함수스코프와 호이스팅

x;  // 미 정의
let x = 3; // x; 에서 에러가 발생하여 도달 할 수 없음

x;  // undefined
var x = 3;
x;  // 3

// 변수를 선언하지 않았는데 그 변수에 접근 할 수 있는 이유
// var로 선언한 변수는 끌어올린다는 뜻의 hoisting 이라는 매커니즘을 따른다.

// 함수 선언도 맨위로 끌어올려지므로 선언전에 호출하는것이 가능하다.
f();
function f() {
    console.log("f");
}
// ★ 변수에 할당된 함수 표현식은 끌어올려 지지 않습니다.

f();   // 정의되지 않음.
let f = function() {
    console.log("f");
}

// 스트릭트 모드 'use strict';
// 암시적 전역변수를 허용하지 않습니다. 
// lint 가 이를 방지해주지만 2중확인이 나쁠것은 없습니다. 